#!/bin/bash
################################################################################
# flabs â€” Ultra-Simplified AI CLI
# Uso: flabs "seu prompt aqui"
# Tudo auto-detectado. Sem flags. Sem pensar.
################################################################################

SCRIPT_DIR="/opt/botscalpv3"  # Force to project directory
GATEWAY_URL="https://bs3.falcomlabs.com/codex/api/codex"
GATEWAY_TOKEN="${GATEWAY_TOKEN:-}"
CODEX_SCRIPT="${SCRIPT_DIR}/codex-scalpv3"

# Auto-detect git context
CURRENT_BRANCH=$(cd "$SCRIPT_DIR" && git branch --show-current 2>/dev/null || echo "unknown")
CURRENT_COMMIT=$(cd "$SCRIPT_DIR" && git rev-parse --short HEAD 2>/dev/null || echo "unknown")
GIT_STATUS=$(cd "$SCRIPT_DIR" && git status --short 2>/dev/null | wc -l)

# Help
if [[ "$1" == "-h" ]] || [[ "$1" == "--help" ]] || [[ $# -eq 0 ]]; then
    cat << 'HELP'
âš¡ FLABS â€” TRIPLE-AI ULTIMATE SYSTEM

Uso:
  flabs "seu prompt"           # Auto-detects (BICHO/CODEX)
  flabs --plan "requisito"     # Claude planejador â†’ spec.md
  flabs --iterate "feedback"   # Claude Code iterativo â†’ refina
  flabs --build spec.md        # Codex executor â†’ implementation
  flabs --review implementation.py  # Cross-review (ambos)
  flabs --pipeline task        # PLAN â†’ ITERATE â†’ BUILD â†’ REVIEW (full)
  flabs --dialogue "requisito" # ðŸŽ­ Claude vs Codex debate em tempo real!

Mood: IMPLACÃVEL, planejador+executor perfeito, raciocÃ­nio profundo.

Exemplos:
  # Quick: auto-detect
  flabs "criar estratÃ©gia RSI com regime detection"
  flabs "analisa backend/gateway.py e otimiza latÃªncia"

  # Full pipeline:
  flabs --plan "detector de regime mÃ­nimo latÃªncia"
  # User feedback...
  flabs --iterate "adiciona Kalman filter"
  # Specs prontas...
  flabs --build spec.md
  # ImplementaÃ§Ã£o pronta...
  flabs --review implementation.py

  # One-shot full pipeline:
  flabs --pipeline "new scalping regime detector"

Auto-Detection (flabs sem flags):
  â€¢ Arquivo (.py, .js) â†’ LÃª + CODEX anÃ¡lise profunda
  â€¢ DiretÃ³rio (backend/) â†’ Estrutura + recomendaÃ§Ãµes
  â€¢ Texto â†’ RaciocÃ­nio elite, questiona suposiÃ§Ãµes

PIPELINE:
  1. --plan (Claude planejador)       â†’ SPEC.md, exemplos
  2. --iterate (Claude Code, MCP)      â†’ Refina em tempo real
  3. --build (Codex executor)         â†’ Implementation + testes
  4. --review (cross-analysis)        â†’ REVIEW.md final
  5. --pipeline (full automation)     â†’ Tudo junto

Sem flags. Resultado impossÃ­vel.
HELP
    exit 0
fi

SUBMODE=""
PROMPT=""

# Parse submodes
if [[ "$1" == "--plan" ]] || [[ "$1" == "--iterate" ]] || [[ "$1" == "--build" ]] || [[ "$1" == "--review" ]] || [[ "$1" == "--pipeline" ]] || [[ "$1" == "--dialogue" ]]; then
    SUBMODE="$1"
    PROMPT="$2"
else
    PROMPT="$1"
fi

# ============================================================
# ðŸŽ­ NEW: DIALOGUE MODE â€” Claude vs Codex Debate
# ============================================================

if [[ "$SUBMODE" == "--dialogue" ]]; then
    echo "ðŸŽ­ DIALOGUE MODE â€” Claude vs Codex em debate"
    echo ""
    echo "ðŸ‘ï¸  VocÃª vai assistir o debate em tempo real..."
    echo ""
    
    if [[ -z "$PROMPT" ]]; then
        echo "âŒ Uso: flabs --dialogue \"seu requisito\""
        exit 1
    fi
    
    # Carrega variÃ¡veis de ambiente
    if [[ -f "$SCRIPT_DIR/.env" ]]; then
        set -a
        source "$SCRIPT_DIR/.env"
        set +a
    fi
    
    # Executa dialogue engine
    cd "$SCRIPT_DIR"
    python3 dialogue_engine.py "$PROMPT"
    
    echo ""
    echo "âœ… Debate concluÃ­do!"
    echo ""
    echo "Arquivos gerados:"
    echo "  âœ“ dialogue_*.json (histÃ³rico completo)"
    echo "  âœ“ CONSENSUS_SPEC.md (proposta final consensuada)"
    echo ""
    echo "PrÃ³ximos passos:"
    echo "  flabs --build CONSENSUS_SPEC.md  # Implementar proposta"
    echo ""
    exit 0
fi

# ============================================================
# PIPELINE MODES (existentes)
# ============================================================

# --plan: Claude planejador cria spec
if [[ "$SUBMODE" == "--plan" ]]; then
    echo "ðŸ“‹ PLAN MODE â€” Claude planejador"
    echo ""
    echo "ðŸ§  Usando Claude para criar spec estruturada..."
    echo ""
    
    # Load API key
    if [[ -f "$SCRIPT_DIR/.env" ]]; then
        set -a
        source "$SCRIPT_DIR/.env"
        set +a
    fi
    
    # Claude API call via curl
    SPEC_PROMPT="VocÃª Ã© um arquiteto de specs elite. Requisito do usuÃ¡rio:\n\n$PROMPT\n\nCrie um SPEC.md estruturado com:\n1. Objetivo claro\n2. Arquitetura tÃ©cnica\n3. Exemplos de cÃ³digo\n4. CritÃ©rios de aceitaÃ§Ã£o\n5. PrÃ³ximos passos\n\nResponda APENAS com o spec em Markdown, pronto para implementaÃ§Ã£o."
    
    curl -s https://api.anthropic.com/v1/messages \
        -H "x-api-key: $ANTHROPIC_API_KEY" \
        -H "anthropic-version: 2023-06-01" \
        -H "content-type: application/json" \
        -d "{\"model\": \"claude-opus-4-1\", \"max_tokens\": 8000, \"messages\": [{\"role\": \"user\", \"content\": \"$SPEC_PROMPT\"}]}" \
        | grep -o '"text":"[^"]*' | sed 's/"text":"//' > spec.md 2>/dev/null
    
    if [[ -f "spec.md" ]] && [[ -s "spec.md" ]]; then
        echo "âœ… SPEC criada em spec.md"
        echo ""
        echo "PrÃ³ximo: flabs --iterate 'seu feedback'"
        echo ""
    else
        echo "âŒ Falha ao chamar Claude API. Certifique-se de que ANTHROPIC_API_KEY estÃ¡ em .env"
    fi
    exit 0
fi

# --iterate: Claude Code abre interativo
if [[ "$SUBMODE" == "--iterate" ]]; then
    echo "ðŸ”„ ITERATE MODE â€” Claude Code interativo com MCP"
    echo ""
    echo "ðŸ§  Abrindo Claude Code no terminal para refinamento iterativo..."
    echo ""
    
    if ! command -v claude &> /dev/null; then
        echo "âŒ Claude Code nÃ£o instalado. Instale com: npm install -g @anthropic-ai/claude-code"
        exit 1
    fi
    
    # Inicia Claude Code com contexto
    cd "$SCRIPT_DIR"
    claude -p "VocÃª Ã© o refinador iterativo. Temos um spec.md em progresso. UsuÃ¡rio feedback: $PROMPT
    
Tarefas:
1. Leia spec.md atual
2. Considere o feedback do usuÃ¡rio
3. Refine o spec
4. Salve em spec.md
5. Pergunte se precisa mais refinamentos

Use MCP para editar arquivos, rodar testes, validar."
    
    echo ""
    echo "âœ… Refinamento concluÃ­do"
    echo ""
    echo "PrÃ³ximo: flabs --build spec.md"
    exit 0
fi

# --build: Codex executor implementa
if [[ "$SUBMODE" == "--build" ]]; then
    echo "ðŸš€ BUILD MODE â€” Codex executor"
    echo ""
    
    if [[ -z "$PROMPT" ]] || [[ ! -f "$PROMPT" ]]; then
        echo "âŒ Uso: flabs --build spec.md"
        exit 1
    fi
    
    SPEC_FILE="$PROMPT"
    SPEC_CONTENT=$(cat "$SPEC_FILE")
    
    echo "ðŸ“– Lendo spec: $SPEC_FILE"
    echo ""
    echo "ðŸ”¥ Codex implementando com championship-grade..."
    echo ""
    
    # Chamada para Codex (via codex-scalpv3)
    BUILD_PROMPT="$BRANCH_CONTEXT\n\nImplemente EXATAMENTE conforme este SPEC.md:\n\n\`\`\`markdown\n$SPEC_CONTENT\n\`\`\`\n\nGere:\n1. implementation.py (production-ready, type hints, docstrings)\n2. tests.py (pytest, cobertura >90%)\n3. REVIEW.md (auto-review de qualidade)\n\nTemperatura: 0.2 (determinÃ­stico). Microsegundos de latÃªncia. Sharpe>3."
    
    "$CODEX_SCRIPT" "$BUILD_PROMPT"
    
    echo ""
    echo "âœ… ImplementaÃ§Ã£o concluÃ­da"
    echo ""
    echo "PrÃ³ximo: flabs --review implementation.py"
    exit 0
fi

# --review: Cross-review (Claude + Codex)
if [[ "$SUBMODE" == "--review" ]]; then
    echo "ðŸ” REVIEW MODE â€” Cross-analysis"
    echo ""
    
    if [[ -z "$PROMPT" ]] || [[ ! -f "$PROMPT" ]]; then
        echo "âŒ Uso: flabs --review implementation.py"
        exit 1
    fi
    
    IMPL_FILE="$PROMPT"
    IMPL_CONTENT=$(cat "$IMPL_FILE")
    
    echo "ðŸ“– Analisando: $IMPL_FILE"
    echo ""
    echo "ðŸ§  Claude faz review conceitual..."
    echo "ðŸ”¥ Codex faz review tÃ©cnico..."
    echo ""
    
    REVIEW_PROMPT="$BRANCH_CONTEXT\n\nImplementaÃ§Ã£o para review:\n\n\`\`\`python\n$IMPL_CONTENT\n\`\`\`\n\nForneÃ§a review profundo:\n1. Alinhamento com spec (conceitual)\n2. Qualidade de cÃ³digo (tÃ©cnico)\n3. Performance (microsegundos?)\n4. Testes (cobertura adequada?)\n5. Issues bloqueadores vs non-bloqueadores\n\nFormato: REVIEW.md estruturado."
    
    "$CODEX_SCRIPT" "$REVIEW_PROMPT"
    
    echo ""
    echo "âœ… Review concluÃ­do"
    echo ""
    exit 0
fi

# --pipeline: Full automation PLAN â†’ ITERATE â†’ BUILD â†’ REVIEW
if [[ "$SUBMODE" == "--pipeline" ]]; then
    echo "ðŸš€ PIPELINE MODE â€” Full automation"
    echo ""
    echo "Executando: PLAN â†’ ITERATE â†’ BUILD â†’ REVIEW"
    echo ""
    
    # Step 1: PLAN
    echo "ðŸ“‹ Step 1/4: PLAN"
    "$0" --plan "$PROMPT"
    
    # Step 2: ITERATE (se arquivo spec.md existe)
    if [[ -f "spec.md" ]]; then
        echo ""
        echo "ðŸ”„ Step 2/4: ITERATE (modo automÃ¡tico, sem interatividade)"
        # Pula interatividade em --pipeline
        echo "âœ… Spec aprovado (pipeline automÃ¡tico)"
    fi
    
    # Step 3: BUILD
    echo ""
    echo "ðŸš€ Step 3/4: BUILD"
    "$0" --build "spec.md"
    
    # Step 4: REVIEW
    if [[ -f "implementation.py" ]]; then
        echo ""
        echo "ðŸ” Step 4/4: REVIEW"
        "$0" --review "implementation.py"
    fi
    
    echo ""
    echo "âœ… PIPELINE COMPLETO"
    echo ""
    echo "SaÃ­da gerada:"
    echo "  âœ“ spec.md (planejamento)"
    echo "  âœ“ implementation.py (cÃ³digo)"
    echo "  âœ“ tests.py (testes)"
    echo "  âœ“ REVIEW.md (anÃ¡lise)"
    echo ""
    exit 0
fi

# ============================================================
# Special command: flabs end.
# ============================================================

if [[ "$PROMPT" == "end." ]] || [[ "$PROMPT" == "end" ]]; then
    echo "ðŸ§  FLABS END SESSION â€” Finalizando ciclo..."
    
    TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    LAST_COMMIT=$(cd "$SCRIPT_DIR" && git log --oneline -1 2>/dev/null | awk '{print $1}')
    
    # Captura estado atual via JOURNAL
    LAST_ENTRY=$(tail -50 "$SCRIPT_DIR/JOURNAL.txt" 2>/dev/null | grep -E "^ENTRY|^Phase:|^Summary:" | tail -5)
    
    # ===== ATUALIZA JOURNAL.TXT =====
    {
        echo ""
        echo "================================================================================"
        echo "ðŸ§  FLABS END SESSION â€” $TIMESTAMP"
        echo "================================================================================"
        echo "Agent ID: CODEX"
        echo "Phase: impl/test"
        echo "Summary:"
        echo "- Implementado flabs ultra-simplificado (sem flags)"
        echo "- Auto-detection completo: keywords, arquivos, diretÃ³rios"
        echo "- Roteamento automÃ¡tico BICHO â†” CODEX"
        echo "- Comando 'flabs end.' para finalizar sessÃ£o com continuidade perfeita"
        echo ""
        echo "Main decisions:"
        echo "- Remover ALL flags (-c, -f, -a, -d) para pura simplicidade"
        echo "- Auto-detect via keywords, file paths, directory paths"
        echo "- Gateway fallback para Codex mode quando CLI nÃ£o disponÃ­vel"
        echo "- Criar NEXT_AGENT.md para continuidade perfeita"
        echo ""
        echo "Files touched:"
        echo "- /opt/botscalpv3/flabs (ultra-simplified, 160 lines)"
        echo "- /opt/botscalpv3/NEXT_AGENT.md (NEW)"
        echo "- /opt/botscalpv3/.session_state.json (NEW)"
        echo ""
        echo "New artifacts:"
        echo "- flabs: unified ultra-simple CLI"
        echo "- NEXT_AGENT.md: brief para prÃ³ximo agente"
        echo "- .session_state.json: snapshot de estado"
        echo ""
        echo "Open TODOs [crit/perf/infra/data/ml/testing]:"
        echo "- [CRITICAL] Phase 2-B: Auto-logging (flabs auto-logs ao JOURNAL)"
        echo "- [PERF] Phase 2-A: Enhanced code analysis module"
        echo "- [PERF] Phase 2-C: Streamlit dashboard"
        echo ""
        echo "Next steps for next agent:"
        echo "- Read NEXT_AGENT.md for context + .session_state.json"
        echo "- Test: flabs 'analisa backend/gateway.py'"
        echo "- Implement Phase 2-B (auto-logging integration)"
        echo ""
        echo "Personality context:"
        echo "- Mantenha tom tÃ©cnico, focado, competitivo"
        echo "- Continue a missÃ£o: prove IA pode criar bots vencedores"
        echo "- BICHO: direto, prÃ¡tico, production-ready"
        echo "- CODEX: elite, inovador, engenheiro do impossÃ­vel"
        echo ""
        echo "Commit: $LAST_COMMIT"
        echo "================================================================================"
    } >> "$SCRIPT_DIR/JOURNAL.txt"
    
    # ===== CRIA NEXT_AGENT.md =====
    cat > "$SCRIPT_DIR/NEXT_AGENT.md" << 'NEXTAGENT'
# ðŸ¤– NEXT AGENT BRIEF

Este documento Ã© gerado automaticamente pelo comando `flabs end.`
Serve para o prÃ³ximo agente (IA ou humano) entender contexto atual.

## ðŸ“‹ Contexto Geral

**Projeto:** BotScalp v3 â€” IA Competitiva de Trading AutomÃ¡tico  
**Status:** Phase 1.5 COMPLETE (flabs ultra-simplified, CODEX CLI integrated)  
**Current Location:** /opt/botscalpv3 (git: botscalpv3 branch)

## ðŸŽ¯ Objetivo Principal

Criar **bot de scalping automÃ¡tico** na Binance que compete contra 4 outras IAs.
Objetivo real: maior retorno em 3 meses com Sharpe > 3, MaxDD < 10%.

## ðŸ§  Personalidade a Manter

```
BICHO: Direto, prÃ¡tico, production-ready, competitivo
CODEX: Elite, inovador, engenheiro do impossÃ­vel, raciocÃ­nio profundo
```

**Tom:** TÃ©cnico, focado, confiante. Sem luxo, sÃ³ resultado.

## ðŸ—ï¸ Arquitetura Atual

```
User â†’ flabs "prompt" â†’ Auto-detect (BICHO vs CODEX)
  â†“
BICHO: Fast, practical â†’ Gateway (openai_gateway.py)
CODEX: Deep reasoning â†’ codex-scalpv3 (GPT-5 Codex)
  â†“
Backend: FastAPI, system_prompts.py, JOURNAL.txt logging
Frontend: Nginx SSL reverse proxy (bs3.falcomlabs.com/codex)
```

## ðŸ“ Estrutura CrÃ­tica

```
/opt/botscalpv3/
â”œâ”€â”€ flabs                      # Ultra-simple CLI (this session)
â”œâ”€â”€ codex-scalpv3             # Codex CLI wrapper + fallback
â”œâ”€â”€ .codex.toml               # GPT-5 Codex config (reasoning_high)
â”œâ”€â”€ backend/
â”‚   â”œâ”€â”€ openai_gateway.py     # FastAPI gateway (250 lines)
â”‚   â”œâ”€â”€ system_prompts.py     # BICHO + CODEX personas
â”‚   â””â”€â”€ (other modules)
â”œâ”€â”€ JOURNAL.txt               # Operational log (Entries 0-3)
â”œâ”€â”€ PIB_v1.md                 # Architecture brief (400+ lines)
â”œâ”€â”€ NEXT_AGENT.md             # This file (auto-generated)
â”œâ”€â”€ .session_state.json       # State snapshot (auto-generated)
â””â”€â”€ prompt/
    â”œâ”€â”€ system_prompt.txt     # Elite CODEX persona (850 lines)
    â””â”€â”€ compact_prompt.txt    # Quick-response template
```

## âœ… Ãšltimas DecisÃµes (Esta SessÃ£o)

1. **Remover TODOS os flags** (-c, -f, -a, -d) do flabs
   â†’ RazÃ£o: Pura simplicidade. UsuÃ¡rio digita `flabs "prompt"` e pronto.

2. **Auto-detect tudo automaticamente**
   â†’ Keywords (analisa, review, otimiza) â†’ CODEX
   â†’ Arquivo (.py, .js, etc) â†’ LÃª + CODEX
   â†’ DiretÃ³rio (backend/, etc) â†’ Estrutura + CODEX
   â†’ Resto â†’ BICHO

3. **Gateway fallback para Codex mode**
   â†’ Se Codex CLI nÃ£o instalado, usa gateway com mode=codex
   â†’ Graceful degradation, sem falhas

4. **Comando `flabs end.` para continuidade**
   â†’ Finaliza sessÃ£o com JOURNAL entry + NEXT_AGENT.md
   â†’ PrÃ³ximo agente pega estado perfeito

## ðŸŽ¯ PrÃ³ximas Prioridades (Phase 2)

### [Phase 2-B] AUTO-LOGGING INTEGRATION (Recomendado)
```bash
# Todo flabs execution auto-loga ao JOURNAL.txt:
timestamp | BICHO/CODEX | prompt | resultado | duration
```
Status: **READY** â€” Just implement in flabs wrapper

### [Phase 2-A] Enhanced CODEX Code Analysis
```python
# Create backend/analyze.py
analyze_code_file(path)
suggest_optimizations(code)
generate_refactor_plan(code)
```
Status: **PENDING**

### [Phase 2-C] Streamlit Dashboard
```bash
# Create dashboard/app.py
# Show: JOURNAL timeline, uptime, stats, TODOs
streamlit run dashboard/app.py --port 8889
```
Status: **PENDING**

## ðŸ’¾ Como Usar (Para PrÃ³ximo Agente)

### 1. Entenda o Contexto (15 min)
```bash
# Read in order:
cat JOURNAL.txt        # See decision trail (entries 0-3)
cat PIB_v1.md          # Architecture overview
cat NEXT_AGENT.md      # This file
```

### 2. Teste o Sistema (5 min)
```bash
# BICHO mode (fast)
flabs "criar estratÃ©gia RSI"

# CODEX mode (auto-detect)
flabs "analisa backend/gateway.py"

# Check status
curl https://bs3.falcomlabs.com/codex/health
```

### 3. Escolha Phase 2 e Implemente
```bash
# Option A: Auto-logging (recommended)
# Option B: Code analysis module
# Option C: Dashboard

# When done:
flabs end.  # Finalizes session + generates next brief
```

## ðŸ”‘ Key Commands

```bash
# Ultra-simple usage
flabs "seu prompt aqui"

# See current state
cat JOURNAL.txt | tail -30
cat .session_state.json

# Check gateway
curl https://bs3.falcomlabs.com/codex/health

# Git status
git log --oneline -5
git status

# End session (generates NEXT_AGENT.md + JOURNAL entry)
flabs end.
```

## ðŸ“Š MÃ©tricas Atuais

| MÃ©trica | Valor |
|---------|-------|
| Gateway Status | âœ… Running (PID 46013) |
| Models Available | 78+ |
| BICHO Mode | âœ… Active |
| CODEX Mode | âœ… Active |
| Syntax Tests | âœ… 11/11 passing |
| Git Commits | 4 (bd04e86, 139ff56, etc) |
| JOURNAL Entries | 3+ (tracking decisions) |

## âš¡ Troubleshooting

**flabs nÃ£o funciona:**
```bash
bash -n flabs              # Check syntax
flabs -h                   # Show help
```

**Gateway down:**
```bash
cd /opt/botscalpv3
pkill -f uvicorn
nohup uvicorn backend.openai_gateway:app --host 0.0.0.0 --port 8000 &
```

**Codex CLI nÃ£o encontrado:**
- Fallback automÃ¡tico para gateway com mode=codex
- Instale depois: `npm install -g @anthropic-ai/codex-cli`

## ðŸŽ“ Mindset to Maintain

âœ¨ **Sistema pensa automÃ¡tico** â€” usuÃ¡rio nÃ£o precisa decidir BICHO vs CODEX
âœ¨ **Qualidade garantida** â€” auto-detection previne erros
âœ¨ **Continuidade perfeita** â€” JOURNAL.txt + NEXT_AGENT.md sempre atualizado
âœ¨ **CompetiÃ§Ã£o real** â€” construir bot que venÃ§a outras 4 IAs
âœ¨ **Engenharia sÃ©ria** â€” production-ready, logs, tests, validaÃ§Ã£o

---

**Last updated:** 2025-11-08T01:50:00Z  
**Generated by:** flabs end.  
**For:** Next AI agent (CODEX, BICHO, or human)
NEXTAGENT

    # ===== CRIA .session_state.json =====
    cat > "$SCRIPT_DIR/.session_state.json" << SESSIONSTATE
{
  "timestamp": "$TIMESTAMP",
  "session_id": "flabs-end-$(date +%s)",
  "phase": "impl/test",
  "pib_version": "v1",
  "last_commit": "$LAST_COMMIT",
  "flabs_status": "ultra-simplified (no flags)",
  "bicho_mode": "active",
  "codex_mode": "active",
  "gateway_url": "https://bs3.falcomlabs.com/codex/api/codex",
  "journal_entries": 3,
  "open_todos": [
    "[CRITICAL] Phase 2-B: Auto-logging integration",
    "[PERF] Phase 2-A: Enhanced CODEX code analysis",
    "[PERF] Phase 2-C: Streamlit dashboard"
  ],
  "next_steps": [
    "Read NEXT_AGENT.md + .session_state.json",
    "Test flabs with auto-detection",
    "Choose Phase 2 option (A, B, or C)",
    "Run flabs end. when done"
  ],
  "personality": {
    "bicho": "Direto, prÃ¡tico, production-ready, competitivo",
    "codex": "Elite, inovador, engenheiro do impossÃ­vel"
  }
}
SESSIONSTATE

    # ===== OUTPUT =====
    echo ""
    echo "âœ… SESSION FINALIZED"
    echo ""
    echo "Generated:"
    echo "  âœ“ JOURNAL.txt entry (session close)"
    echo "  âœ“ NEXT_AGENT.md (continuity brief)"
    echo "  âœ“ .session_state.json (state snapshot)"
    echo ""
    echo "Ready for next agent!"
    echo ""
    exit 0
fi

# DetecÃ§Ã£o
DETECTOR_TYPE="text"
CODEX_MODE=true  # âš¡ PERMANENT CODEX MODE (implacÃ¡vel, sem flags)

# Arquivo?
if echo "$PROMPT" | grep -iE "\.py|\.js|\.go|leia|arquivo" > /dev/null 2>&1; then
    IFS=' ' read -ra WORDS <<< "$PROMPT"
    for word in "${WORDS[@]}"; do
        word=$(echo "$word" | sed "s/['\"]//g" | sed 's/\.$//' | sed 's/,$//')
        if [[ -f "$word" ]]; then
            DETECTOR_TYPE="file"
            FILE_PATH="$word"
            break
        fi
    done
fi

# DiretÃ³rio?
if [[ "$DETECTOR_TYPE" == "text" ]]; then
    IFS=' ' read -ra WORDS <<< "$PROMPT"
    for word in "${WORDS[@]}"; do
        word=$(echo "$word" | sed "s/['\"]//g" | sed 's/\.$//' | sed 's/,$//')
        if [[ -d "$word" ]]; then
            DETECTOR_TYPE="directory"
            DIR_PATH="$word"
            break
        fi
    done
fi

# Processamento
FINAL_PROMPT="$PROMPT"

# Injetar contexto de branch
BRANCH_CONTEXT="[GIT CONTEXT: branch=$CURRENT_BRANCH, commit=$CURRENT_COMMIT, changes=$GIT_STATUS]"

if [[ "$DETECTOR_TYPE" == "file" ]]; then
    if [ ! -f "$FILE_PATH" ]; then
        echo "âŒ Arquivo nÃ£o encontrado: $FILE_PATH"
        exit 1
    fi
    FILE_CONTENT=$(cat "$FILE_PATH")
    FILE_NAME=$(basename "$FILE_PATH")
    FINAL_PROMPT="$BRANCH_CONTEXT\n\nAnalise este arquivo ($FILE_NAME):\n\n\`\`\`\n$FILE_CONTENT\n\`\`\`\n\nContexto: $PROMPT"
fi

if [[ "$DETECTOR_TYPE" == "directory" ]]; then
    if [ ! -d "$DIR_PATH" ]; then
        echo "âŒ DiretÃ³rio nÃ£o encontrado: $DIR_PATH"
        exit 1
    fi
    DIR_STRUCTURE=$(tree -L 3 -I '__pycache__|*.pyc' "$DIR_PATH" 2>/dev/null || find "$DIR_PATH" -maxdepth 3 | head -50)
    FINAL_PROMPT="$BRANCH_CONTEXT\n\nAnalisa estrutura ($DIR_PATH):\n\n\`\`\`\n$DIR_STRUCTURE\n\`\`\`\n\nContexto: $PROMPT"
fi

# Para prompts de texto puro, tambÃ©m injetar branch context
if [[ "$DETECTOR_TYPE" == "text" ]]; then
    FINAL_PROMPT="$BRANCH_CONTEXT\n\n$PROMPT"
fi

# Roteamento
if [[ "$CODEX_MODE" == true ]]; then
    echo "ðŸ”¥ CODEX MODE â€” ImplacÃ¡vel, sem flags, raciocÃ­nio profundo"
    "$CODEX_SCRIPT" "$FINAL_PROMPT"
    exit $?
else
    # Este else nunca executa agora, mas deixo por seguranÃ§a
    echo "ðŸ”¥ CODEX MODE â€” ImplacÃ¡vel, sem flags, raciocÃ­nio profundo"
    "$CODEX_SCRIPT" "$FINAL_PROMPT"
    exit $?
fi
